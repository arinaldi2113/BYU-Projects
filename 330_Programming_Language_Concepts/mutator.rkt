#lang plai/mutator

(allocator-setup "gcMark.rkt" 10)

;; How do we handle empty lists?

;; Need to move the commented area around according to the test case
;; This is because each test case needs a different heap size. 

#|
;; Test Case - HeapSize: 10 (simple define)
(define x 'blah)

;; Test Case - HeapSize: 10 (simple cons)
(cons 'one 'two)

;; Test Case - HeapSize: 20 (simple cons with extra space)
(cons 'one 'two)

;; Test Case - HeapSize: 10 (forced collection)
(cons 'one 'two)
(define x 'blah)

;; Test Case - HeapSize: 20 (many defines with nums)
(define x 10000)
(define y 4)
(define z 3)
(define u 2)
(define t x)

(test/value=? x 10000)
(test/value=? y 4)
(test/location=? x t)

;; Test Case - HeapSize: 20 (many defines with symbols)
(define x 'hello)
(define y 'bob)
(define z 'I)
(define u 'am)
(define t x)

(test/value=? x 'hello)
(test/value=? y 'bob)
(test/location=? x t)

;; Test Case - HeapSize: 20 (many defines with booleans)
(define x #t)
(define y #f)
(define z #f)
(define u #t)
(define t x)

(test/value=? x #t)
(test/value=? y #f)
(test/location=? x t)

;; Test Case - HeapSize: 30 (many defines with funs)
(define (fun x)
  (lambda () x))
(define (fun2 y)
  (lambda () y))
(define (fun3 z)
  (lambda () z))
(define (fun4 d)
  (lambda () d))
(define c (fun 10))

;; Test Case - HeapSize: 20 (full heap)
(define x '1)
(define y '2)
(define z '3)
(define u '4)
(define t '5)
(define d x)

(test/value=? x '1)
(test/value=? y '2)
(test/location=? x d)

;; Test Case - HeapSize: 20 (run out of memory)
(define x '1)
(define y '2)
(define z '3)
(define u '4)
(define t '5)
(define d '6)
(define e '7)

;; Test Case - HeapSize: 10 (one function with multiple params)
(define (fun2 x y)
  (lambda () x))

;; Test Case - HeapSize: 10 (two functions)
(define (fun x)
  (lambda () x))
(define (fun2 x y)
  (lambda () x))

;; Test Case - HeapSize: 30 (three functions)
(define (fun x)
  (lambda () x))
(define (fun2 x y)
  (lambda () x))
(define (fun3 x)
  (lambda () x))

;; Test Case - HeapSize: 20 (definition of function)
(define (fun x)
  x)

(test/value=? (fun 100) 100)
(test/value=? (fun 10) 10)
(test/value=? (fun 'hello) 'hello)
(test/value=? (fun 1) 1)
(test/value=? (fun 2) 2)
(test/value=? (fun 3) 3)
(test/value=? (fun 4) 4)
(test/value=? (fun 5) 5)
(test/value=? (fun 6) 6)


;; Test Case - HeapSize: 60 (functions with env)
(define (add5 y)
  (+ 5 y))

(test/value=? (add5 2) 7)
(test/value=? (add5 10) 15)
(test/value=? (add5 -1) 4)
  
(define x 5)
(define (addX y)
  (+ x y))

(test/value=? (addX 2) 7)
(test/value=? (addX 10) 15)
(test/value=? (addX -1) 4)

(define y 1)
(define z 2)
(define (addYZ d e)
  (+ y z d e))

(test/value=? (addYZ 3 4) 10)
(test/value=? (addYZ 5 10) 18)
(test/value=? (addYZ -1 -2) 0)

(test/value=? (addYZ (addX 1) (addYZ 1 2)) 15)
(test/value=? (addYZ (addYZ (addYZ 1 1) (addX 1)) (add5 1)) 23)

(define lst (cons 1 (cons 2 (cons 3 0))))

(test/value=? (add5 (first lst)) 6)
(test/value=? (addX (first lst)) 6)
(test/value=? (addYZ (first lst) (first (rest lst))) 6)
(test/value=? (addYZ (first (rest lst)) (first (rest (rest lst)))) 8)

(define (funLam x y)
  (lambda (x y) (+ x y)))

(funLam 1 2)

(define lst2 (cons x 1))

(test/location=? x (first lst2))



;; TEST CASE - Heap Size 20 (test booleans and booleans with functions
(define bool #t)
(test/value=? bool #t)
(set! bool #f)
(test/value=? bool #f)
(define bool2 bool)
(test/location=? bool bool2)

(define (boolFun b1 b2)
  (eq? b1 b2))

(test/value=? (boolFun #t #f) #f)

(define (fun b1)
  (if b1
      'even
      'odd))

(set! bool #t)
(test/value=? (fun #t) 'even)
(test/value=? (fun #f) 'odd)
(test/value=? (fun bool) 'even)
(set! bool #f)
(test/value=? (fun bool) 'odd)

;; Test Case - HeapSize: 10 (Lots of collection)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'one 'one)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'two 'two)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'three 'three)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)
(cons 'four 'four)

;; Test Case - HeapSize: 20 (list of functions and function value)
(define (fun x)
  (lambda () x))
(define fun3 (fun 100))
(define lst (cons (fun3) (fun3)))
(test/value=? (first lst) 100)
(test/value=? (rest lst) 100)
(define z (fun 'hello))
(test/value=? (z) 'hello)

;; Test Case - HeapSize: 40 (long list)
(define longList (cons 'one (cons 'two (cons 'three (cons 'four (cons 'five 'empty))))))

(test/value=? (first longList) 'one)
(test/value=? (first (rest longList)) 'two)
(test/value=? (first (rest (rest longList))) 'three)
(test/value=? (first (rest (rest (rest longList)))) 'four)
(test/value=? (first (rest (rest (rest (rest longList))))) 'five)

|#



